 //ROOT header files
#include <TROOT.h>
#include <TAttFill.h>
#include <TAxis.h>
#include <TCanvas.h>
#include <TColor.h>
#include <TF1.h>
#include <TFile.h>
#include <TFitResult.h>
#include <TGraphErrors.h>
#include <THStack.h>
#include <TH1.h>
#include <TH1D.h>
#include <TKey.h>
#include <TLatex.h>
#include <TLegend.h>
#include <TLorentzVector.h>
#include <TMath.h>
#include <TMatrixDSym.h>
#include <TPad.h>
#include <TPaveStats.h>
#include <TPaveText.h>
#include <TStyle.h>
#include <TVirtualFitter.h>

//C or C++ header files
#include <stdio.h>
#include <stdlib.h>
#include <cstdlib> //as stdlib.h
#include <cstdio>
#include <cmath>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <iomanip> 

#include <Rtypes.h> // to use kColor

using namespace std;

void zlljets_ZpT_recoGenAna() {

  TH1::SetDefaultSumw2();   

  vector<string> fileName;
  fileName.push_back("zmumujetsAna.root");
  fileName.push_back("zeejets_Axe_noSkim.root");

  vector<string> sample;
  sample.push_back("Z(#mu#mu)+jets");
  sample.push_back("Z(ee)+jets");

  vector<TH1D*> hZpTreco;
  vector<TH1D*> hZpTgen;  

  Int_t nFiles = (Int_t)fileName.size();
  Int_t histColor[] = {kBlue,kOrange,kRed,kGreen};

  for(Int_t i = 0; i < nFiles; i++) {

    cout<<"fileName : "<<fileName[i]<<endl;

    TFile* f = TFile::Open(fileName[i].c_str(),"READ");
    
    if (!f || !f->IsOpen()) {

      cout<<"*******************************"<<endl;
      cout<<"Error opening file \""<<fileName[i]<<"\".\nApplication will be terminated."<<endl;
      cout<<"*******************************"<<endl;
      exit(EXIT_FAILURE);

    }

    hZpTreco.push_back((TH1D*)f->Get("HZtoLLRecoPt"));
    hZpTgen.push_back((TH1D*)f->Get("HZtoLLGenPt"));

    if (!(hZpTreco[i] && hZpTgen[i])) {

      cout << "Error: could not get histograms from file " << fileName[i] << endl;
      exit(EXIT_FAILURE);

    }
	 
  }

  for (Int_t j = 0; j < nFiles; j++) {

    hZpTreco[j]->SetStats(kFALSE);   // to avoid drawing statistic box
    hZpTreco[j]->SetLineColor(histColor[j]);
    hZpTreco[j]->Scale(1./hZpTreco[j]->Integral(0,1 + hZpTreco[j]->GetNbinsX()));  // normalize to unity, use integral including underflow & overflow bin
    //hZpTreco[j]->SetFillColorAlpha(histColor[j], 0.80);
    hZpTgen[j]->SetStats(kFALSE);   // to avoid drawing statistic box
    hZpTgen[j]->SetLineColor(histColor[j+2]);
    hZpTgen[j]->Scale(1./hZpTgen[j]->Integral(0,1 + hZpTgen[j]->GetNbinsX()));

  }

  TCanvas *cZtomumuPtRecoGen = new TCanvas("cZtomumuPtRecoGen","");
  TLegend *legZtomumuPtRecoGen = new TLegend(0.70,0.7,0.89,0.89); 
  cZtomumuPtRecoGen->SetLogy();
  //cout <<"Drawing histograms and ratio"<<endl;
  hZpTreco[0]->GetXaxis()->SetTitle("Z_{pT}[GeV]");
  hZpTreco[0]->GetXaxis()->SetTitleSize(0.04);
  hZpTreco[0]->GetYaxis()->SetTitle("# events");
  hZpTreco[0]->GetYaxis()->SetTitleSize(0.045);
  hZpTreco[0]->GetYaxis()->CenterTitle();
  hZpTreco[0]->Draw("HE");
  hZpTgen[0]->Draw("HE SAME");
  legZtomumuPtRecoGen->AddEntry(hZpTreco[0],"Z(#mu#mu) reco","l");
  legZtomumuPtRecoGen->AddEntry(hZpTgen[0],"Z(#mu#mu) gen","l");
  gStyle->SetStatStyle(0);
  legZtomumuPtRecoGen->Draw(); 
  legZtomumuPtRecoGen->SetMargin(0.3); 
  legZtomumuPtRecoGen->SetBorderSize(0);

  TCanvas *cZtoeePtRecoGen = new TCanvas("cZtoeePtRecoGen","");
  TLegend *legZtoeePtRecoGen = new TLegend(0.70,0.7,0.89,0.89); 
  cZtoeePtRecoGen->SetLogy();
  //cout <<"Drawing histograms and ratio"<<endl;
  hZpTreco[1]->GetXaxis()->SetTitle("Z_{pT}[GeV]");
  hZpTreco[1]->GetXaxis()->SetTitleSize(0.04);
  hZpTreco[1]->GetYaxis()->SetTitle("# events");
  hZpTreco[1]->GetYaxis()->SetTitleSize(0.045);
  hZpTreco[1]->GetYaxis()->CenterTitle();
  hZpTreco[1]->Draw("HE");
  hZpTgen[1]->Draw("HE SAME");
  legZtoeePtRecoGen->AddEntry(hZpTreco[1],"Z(ee) reco","l");
  legZtoeePtRecoGen->AddEntry(hZpTgen[1],"Z(ee) gen","l");
  gStyle->SetStatStyle(0);
  legZtoeePtRecoGen->Draw(); 
  legZtoeePtRecoGen->SetMargin(0.3); 
  legZtoeePtRecoGen->SetBorderSize(0);

  TCanvas *cZtollPtRecoGen = new TCanvas("cZtollPtRecoGen","");
  TLegend *legZtollPtRecoGen = new TLegend(0.70,0.7,0.89,0.89); 
  cZtollPtRecoGen->SetLogy();
  //cout <<"Drawing histograms and ratio"<<endl;
  hZpTreco[0]->GetXaxis()->SetTitle("Z_{pT}[GeV]");
  hZpTreco[0]->GetXaxis()->SetTitleSize(0.04);
  hZpTreco[0]->GetYaxis()->SetTitle("# events");
  hZpTreco[0]->GetYaxis()->SetTitleSize(0.045);
  hZpTreco[0]->GetYaxis()->CenterTitle();
  hZpTreco[0]->Draw("HE");
  hZpTgen[0]->Draw("HE SAME");
  hZpTreco[1]->Draw("HE SAME");
  hZpTgen[1]->Draw("HE SAME");
  legZtollPtRecoGen->AddEntry(hZpTreco[0],"Z(#mu#mu) reco","l");
  legZtollPtRecoGen->AddEntry(hZpTgen[0],"Z(#mu#mu) gen","l");
  legZtollPtRecoGen->AddEntry(hZpTreco[1],"Z(ee) reco","l");
  legZtollPtRecoGen->AddEntry(hZpTgen[1],"Z(ee) gen","l");
  gStyle->SetStatStyle(0);
  legZtollPtRecoGen->Draw(); 
  legZtollPtRecoGen->SetMargin(0.3); 
  legZtollPtRecoGen->SetBorderSize(0);

  if( hZpTreco[0]->GetNbinsX() == hZpTreco[1]->GetNbinsX() ) {

    Int_t bins = hZpTreco[0]->GetNbinsX();
    Double_t firstEdge = hZpTreco[0]->GetXaxis()->GetBinLowEdge(1);
    Double_t lastEdge = hZpTreco[0]->GetXaxis()->GetBinUpEdge(bins);
    TH1D *hZpTMuEleRecoRatio = new TH1D("hZpTMuEleRecoRatio","",bins,firstEdge,lastEdge);
    

    // cout << "hZpTreco[0]->GetNbinsX() : "<< hZpTreco[0]->GetNbinsX() << endl;
    // cout << "hZpTreco[1]->GetNbinsX() : "<< hZpTreco[1]->GetNbinsX() << endl;
    // cout << "hZpTMuEleGenRatio->GetNbinsX() : "<< hZpTMuEleGenRatio->GetNbinsX() << endl;

    if (!hZpTMuEleRecoRatio->Divide(hZpTreco[0],hZpTreco[1])) cout << " Error in hZpTMuEleRecoRatio->Divide(hZpTreco[0],hZpTreco[1])" << endl;
    hZpTMuEleRecoRatio->SetStats(kFALSE);
   
    TCanvas *cZpTMuEleRecoRatio = new TCanvas("cZpTMuEleRecoRatio","");
    hZpTMuEleRecoRatio->GetXaxis()->SetTitle("Z_{pT}[GeV]");
    hZpTMuEleRecoRatio->GetXaxis()->SetTitleSize(0.04);
    hZpTMuEleRecoRatio->GetYaxis()->SetTitle("reco pT_{Z(#mu#mu)} / pT_{Z(ee)} ");
    hZpTMuEleRecoRatio->GetYaxis()->SetTitleSize(0.045);
    hZpTMuEleRecoRatio->GetYaxis()->SetRangeUser(0.5,1.5);
    hZpTMuEleRecoRatio->GetYaxis()->CenterTitle();
    hZpTMuEleRecoRatio->Draw("E");
    gStyle->SetStatStyle(0);
    
  }

  if (hZpTgen[0]->GetNbinsX() == hZpTgen[1]->GetNbinsX()) {

    Int_t bins = hZpTgen[0]->GetNbinsX();
    Double_t firstEdge = hZpTgen[0]->GetXaxis()->GetBinLowEdge(1);
    Double_t lastEdge = hZpTgen[0]->GetXaxis()->GetBinUpEdge(bins);
    TH1D *hZpTMuEleGenRatio = new TH1D("hZpTMuEleGenRatio","",bins,firstEdge,lastEdge);

    if (!hZpTMuEleGenRatio->Divide(hZpTgen[0],hZpTgen[1])) cout << " Error in hZpTMuEleGenRatio->Divide(hZpTgen[0],hZpTgen[1])" << endl;
    hZpTMuEleGenRatio->SetStats(kFALSE);

    TCanvas *cZpTMuEleGenRatio = new TCanvas("cZpTMuEleGenRatio","");
    hZpTMuEleGenRatio->GetXaxis()->SetTitle("Z_{pT}[GeV]");
    hZpTMuEleGenRatio->GetXaxis()->SetTitleSize(0.04);
    hZpTMuEleGenRatio->GetYaxis()->SetTitle("gen pT_{Z(#mu#mu)} / pT_{Z(ee)} ");
    hZpTMuEleGenRatio->GetYaxis()->SetTitleSize(0.045);
    hZpTMuEleGenRatio->GetYaxis()->SetRangeUser(0.5,1.5);
    hZpTMuEleGenRatio->GetYaxis()->CenterTitle();
    hZpTMuEleGenRatio->Draw("E");
    gStyle->SetStatStyle(0);

  }


}
